import { combineReducers } from "redux";
import { NEW_PETITION, UPDATE_PETITION } from "frontend/src/actions/petitions";
import { normalizeOnePetition } from "frontend/src/normalize/petitions";
import { merge } from "lodash";
import { NEW_CASE_FOR_PETITION } from "../actions/petitions";

/**
 * Slice of state explaining if petitions are currently being collected from the server.
 * @param {} state
 * @param {*} action
 */
export function petitionsUpdatesReducer(
  state = { updateInProgress: false },
  action
) {
  switch (action.type) {
    case "FETCH_PETITIONS_SUCCEEDED":
      return { ...state, updateInProgress: false };
    default:
      return state;
  }
  return state;
}

const initialCollectionState = {
  entities: {
    petitions: {},
    cases: {},
    charges: {},
  },
  petitionIds: [],
  editingPetitionId: null,
};

/**
 * Slice of state with a collection of petitions that could be generated by the server.
 *
 * This is a normalized slice, shaped like:
 *
 * petitionCollection:
 *   entities:
 *     petitions: {}
 *     cases: {}
 *     charges: {}
 *   petitionIds: [petition-ids]
 */
export function petitionCollectionReducer(
  state = initialCollectionState,
  action
) {
  console.log("petitionCollectionReducer");
  switch (action.type) {
    case NEW_PETITION: {
      // Add a new petition
      const newPetition = action.payload;
      // create a new id for this new petition, only if necessary.
      // (if the petitions is from the server, it'llneed a local ID.
      //  but if it was created locally, the New Petition component
      //  will come up with the new id.)
      const newId = newPetition.id || state.petitionIds.length.toString();
      const normalizedPetition = normalizeOnePetition(newPetition, newId);
      const newState = {
        entities: {
          petitions: merge({}, state.entities.petitions, {
            [newId]:
              normalizedPetition.entities.petitions[normalizedPetition.result],
          }),
          cases: merge(
            {},
            state.entities.cases,
            normalizedPetition.entities.cases
          ),
          charges: merge(
            {},
            state.entities.charges,
            normalizedPetition.entities.charges
          ),
        },
        petitionIds: [...state.petitionIds, newId],
        editingPetitionId: newId,
      };
      return newState;
    }
    case UPDATE_PETITION: {
      console.log("updating a petition.");
      // Update a petition.

      // NB - to handle updates to things like cases, do I
      // normalize the updateObject with the PetitionSchema?
      const { petitionId, updateObject } = action.payload;

      const casesUpdate = updateObject.cases || null;
      if (casesUpdate) {
        delete updateObject.cases;
      }

      const newState = {
        editingPetitionId: state.editingPetitionId,
        petitionIds: [...state.petitionIds],
        entities: {
          petitions: merge({}, state.entities.petitions, {
            [petitionId]: merge(
              {},
              state.entities.petitions[petitionId],
              updateObject
            ),
          }),
          cases: { ...state.entities.cases },
          charges: { ...state.entities.charges },
        },
      };
      return newState;
    }

    case NEW_CASE_FOR_PETITION: {
      // Add a new case to a petition.
      const { petitionId, caseId, caseDefaults } = action.payload;
      console.log("NEW_CASE_FOR_PETITION");
      const newCaseIds = state.entities.petitions[petitionId].cases
        ? // set operation makes sure we're not duplicating cases.
          Array.from(
            new Set([...state.entities.petitions[petitionId].cases, caseId])
          )
        : [caseId];

      const newState = {
        editingPetitionId: state.editingPetitionId,
        petitionIds: [...state.petitionIds],
        entities: {
          petitions: merge({}, state.entities.petitions, {
            [petitionId]: merge({}, state.entities.petitions[petitionId], {
              cases: newCaseIds,
            }),
          }),
          cases: merge({}, state.entities.cases, {
            [caseId]: merge(
              {},
              {
                id: caseId,
                docket_number: caseId,
                editing: false,
              },
              caseDefaults
            ),
          }),
          charges: { ...state.entities.charges },
        },
      };
      return newState;
    }

    default:
      return state;
  }
  return state;
}

const petitionsReducer = combineReducers({
  petitionUpdates: petitionsUpdatesReducer,
  petitionCollection: petitionCollectionReducer,
});

export default petitionsReducer;
